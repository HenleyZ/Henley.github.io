<!DOCTYPE html>
<html lang="en">
<head>
    <div class="main">
        <div class="newhome artnewhome" style="background-image:  url(/images/ArcadiaMainScreen.png)">

        </div> 
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Henley Zhang</title>
    <link rel="icon" type="image/webp" href="images/lepuff.webp">
    <link rel="stylesheet" href="styles.css">   
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    </div>
</head>
<body>
<div id="main"></div>
<!-- NAVBAR -->
<nav class="navbar">
    <div class="navbar__container">
    <a href="/" id="navbar__logo"><img src="arts/name_small.png" id="jig" alt="jig">Henley</a>
    <div class="navbar__toggle" id="mobile-menu">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </div>
    <ul class="navbar__menu">
        <li class="navbar__item">
            <a href="/index.html#main" class="navbar__links">home</a>
        </li>
        <li class="navbar__item">
            <a href="/index.html#Projects" class="navbar__links">
             projects   
            </a>
        </li>
    
        <li class="navbar__item">
            <a href="/arts.html" class="navbar__links">
             arts   
            </a>
        </li>
        <li class="navbar__item">
            <a href="/index.html#Fun" class="navbar__links">
             fun
            </a>
        </li>    
    </ul>
</div>
</nav>
<!-- HERO -->
<div class="main">
    <div class="main__container">

        <div class="smallbreak"></div>

        <iframe width="1200" height="615" src="https://www.youtube.com/embed/h-hqKZcj1wE?si=oQGeVbH7xLlc9Xqd" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        

    
    </div>


    <div class="newhome artnewhome" style="background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(/images/arcadiamap.png)">
        <h4 style="color: white;">Technical Details</h4>
    </div> 
            
    <div class="main__container" style="height: 100%; margin-bottom: 10rem;">
        <h2 style="font-size: 3rem;">Table of Contents</h2>
            <ul class="tableofcontents">
                <li><a href="#server-authoritative-networking">Server Authoritative Networking </a></li>
                <li><a href="#lag-compensation">Lag Compensation Algorithm</a></li>
                <li><a href="#gun-spray">Gunplay Recoil Algorithm</a></li>
                <li><a href="#gun-pen">Bullet Hitscan Penetration Algorithm</a></li>
                <li><a href="#ai">Fun-to-Play-With AI Bots</a></li>
                <li><a href="#game-framework">Game Framework + Design</a></li>
                <li><a href="#s2smoke">CS2 Volumetric FloodFill Smokes</a></li>
            </ul>
    </div>

    <div class="newhome artnewhome"  id="server-authoritative-networking" style="background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(/images/dust.png)">
        <h4 style="color: white;">Server Authoritative Networking System</h4>
    </div> 
            
    
            
    <div class="main__container" style="height: auto;">
    <div class="smallbreak"></div>
            <iframe width="1060" height="615" src="https://www.youtube.com/embed/NdnWYkCvlsQ?si=U8PMF98eH2XAw9Jv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

            <p>The game is networked using a server authoritative system rather than a P2P client-based system. The advantages are that it is much more secure since the client has no authority to change what happens on the server; it only sends requests that the server acts on, preventing many abuses caused by a modified client. However, this style of networking presents many challenges. The client side has to be programmed to preserve responsiveness in movement and shooting, meaning that actions initiated by the player are split into a local instance and a server instance. The server also has to account for lag compensation; otherwise, the validation of a line trace (a fired bullet) has to account for the passage of time between information being sent from the client to the server.</p>
            <img src="https://docs.elympics.cc/images/overview/sa1.png" alt="diagram" width="90%" style="padding:1rem;">
            <div class="break"></div>
    </div>
    <div id="lag-compensation" class="newhome artnewhome" style="background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(/images/wing.png)">
        <h4 style="color: white;">Custom Lag Compensation Algorithm</h4>
    </div> 
    <div class="main__container" style="height: auto;">
            <div class="smallbreak"></div>

                    
            <!-- <h1 id="lag-compensation">Custom Lag Compensation Algorithm</h1> -->
            <p>Everything seemed alright when I booted up the server on my LAN. The game felt fluid and responsive. However, as soon as I tried to connect to a server my friend hosted 1000 miles away, the networking completely fell apart. None of the bullets I fired hit the target; the bullets that seemed to miss resulted in a kill. I did a lot of research into the problem and discovered the issue of lag compensation. This video explains this topic way better than I could.</p>
            
            <iframe width="1060" height="615" src="https://www.youtube.com/embed/6EwaW2iz4iA?si=DnSXCVcKIKMg-LHQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            
            <p>However, the problem was that I was programming in Unreal Engine, and such a framework did not exist (actually, it does, but for $350!). I basically gave up on the problem until I came across this research paper <a style="color: blueviolet;" href="https://liu.diva-portal.org/smash/get/diva2:1605200/FULLTEXT01.pdf">here</a> detailing a method for developing a lag compensation algorithm along with testing methodology. I soon ended up with this system.</p>
            <div class="container">            <br>
            <ol>
                <li>The server saves a bone map and the location of every single player every tick. The bone map is a hashtable that maps bone names to their local transforms. This location object also maps in a hash table that maps players to their locations. A final double-ended queue maps the player hash tables to the exact server time.</li>
                <li>Each client is constantly pinging the server for the ping. (ex 20ms) This ping is updated and saved on the server.</li>
                <li>When a client fires a lag-compensated shot, it sends the details of the line trace to the server.</li>
                <li>The server uses the saved client's ping along with the current server time to determine exactly what time the client fired the shot on their local instance, which lags behind the server instance in terms of updated information.</li>
                <li>This exact time is searched for in the double-ended queue. The time is between two ticks of the server, so the server fetches those two time hashmaps.</li>
                <li>The two times hash tables are used to find the positions and transforms of the bones of the player at that time. A final calculated bone transform is determined by linearly interpolating between the two transforms.</li>
                <li>The bone transforms are used to reconstruct a hitbox object, which lives on the server.</li>
                <li>The line trace is performed in the world and checks for hits against the hitbox object. If the hit connects, the damage is applied.</li>
            </ol>
            </div>

            <iframe width="1060" height="615" src="https://www.youtube.com/embed/OrWSBLe4Uk4?si=A50ibYXv0-lpts9q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

            <div class="break"></div>
    </div>  
    <div class="newhome artnewhome"  id="gun-spray" style="background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(/images/mirage.png)">
        <h4 style="color: white;">Gun Spray Algorithm</h4>
    </div> 
    <div class="main__container" style="height: auto;">

        <div class="smallbreak"></div>

            
        <iframe width="560" height="315" src="https://www.youtube.com/embed/phR9gfwe0no?si=A1-u3sbPsXerUs9b" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            
        <div class="smallbreak"></div>

            <p>I designed this algorithm through a lot of playtesting and trial and error. Heres how it works. </p>

        <div class="smallbreak"></div>
        <div class="container">  
                <ol>
                    <li>There is an internal heat variable, which is stored on the client and the server as two different versions. The client variables are separated from the server to maintain the spray even in poor network conditions.</li>
                    <li>When a weapon is fired, the heat variable is increased by a certain amount depending on the characteristics of the weapon. For example, SMGs have a higher heat growth multiplier compared to silenced weapons.</li>
                    <li>There are three components to recoil: screenshake, crosshair movement, and crosshair deviation.</li>
                    <li>Screenshake is simply implemented by calling a UE4 screenshake locally, and the shake level depends on the force of the gun.</li>
                    <li>Crosshair movement is implemented by lerping the crosshair to a given amount. This amount is determined by the heat variable as well as the client FPS, so the crosshair movement is consistent across different performing machines.</li>
                    <li>Crosshair deviation is implemented by adjusting the hitscan vector. This amount is also determined by the heat variable. It causes the bullets to fly above the crosshair in the crux of the spray. A small amount of RNG is applied to crosshair deviation, which is tied to the heat variable.</li>
                    <li>When the heat variable exceeds a certain amount (Around 30), it cycles back to an intermediate amount, so that the side-to-side motion happens seamlessly.</li>
                    <li>Any amount of crosshair movement recoil is added to a local variable. When the player stops shooting, the amount of this local variable is used to return the crosshair to the original location. This also takes FPS into account.</li>
                    <li>The whole time, the heat variable decays, depending on the characteristics of the weapon.</li>
                </ol>
        </div>
        
        <div class="smallbreak"></div>
        
            <p>All this complexity allows the spray pattern to follow a consistent characteristic T-shaped pattern found in Valorant and CSGO. The numerous ways spray can be adjusted allow for easy modifications to weapons.</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/SiaqWkY_zPo?si=vYdQbtAZGK6zsTvp" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        
            <div class="break"></div>
    </div>
    <div class="newhome artnewhome"  id="gun-pen" style="background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(/images/penn.png)">
        <h4 style="color: white;">Hitscan Bullet Penetration Algorithm</h4>
    </div> 
    <div class="main__container" style="height: auto;">
            <div class="smallbreak"></div>
            <img src="/images/penetration.png" alt="bullet penetration diagram">
            <div class="smallbreak"></div>

            <div class="container">  
                <ol>
                    <li>The initial line trace is performed (red). When the line trace hits an object, the penetration function is called.</li>
                    <li>The penetration function performs a depth check line trace (blue). The length of this line trace is determined by the penetration value of the shot.</li>
                    <li>If the depth check line trace hits an object, it means that the bullet is capable of penetrating to the other side of the object.</li>
                    <li>The penetration function then performs a final line trace (blue) from the hit location of the depth check line trace to the original line trace hit location.</li>
                    <li>This final line trace's penetration and damage are reduced based on the length of the depth check line trace, which indicates how much of the bullet's power is reduced.</li>
                    <li>This line trace does the usual lag-compensated check for a player hit. It also recursively calls the penetration function when this line trace hits an object.</li>
                    <li>The recursion stops when the penetration value is insufficient to penetrate the following object. There are recursion limits in place to stop infinite loops.</li>
                </ol>
            </div>
        </div>
        
        
</div>




<script src="app.js"></script>
<script src="https://cdn.rawgit.com/michalsnik/aos/2.1.1/dist/aos.js"></script>
<script>
    AOS.init();
  </script>
</body>
</html>